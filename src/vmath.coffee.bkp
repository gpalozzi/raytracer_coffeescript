vmath = {
  # pi
  PI : 3.1415926535897932384626433832795

  # numeric conversion utilities --------------------------
  int : (x) -> parseInt x

  # math utilities --------------------------
  # degrees to radians
  radians : (deg) -> deg / 180 * PI
  # radians to degrees
  degrees : (rad) -> rad / PI * 180
  # integer power of 2
  pow2 : (x) ->
    ret = 1
    for i in [0...x]
      ret *=2
    return ret
  # square
  sqr : (x) -> x * x
  
  # 2d vector Constants -------------------------------
  # zero
  zero2f : new vec2f
  # one
  one2f : new vec2f 1,1
  
  # x, y
  x2f : new vec2f 1,0
  y2f : new vec2f 0,1
  # 3d vector Constants -------------------------------
  # zero
  zero3f : new vec3f
  # one
  one3f : new vec3f 1,1,1
  
  # x, y, z
  x3f : new vec3f 1,0,0
  y3f : new vec3f 0,1,0
  z3f : new vec3f 0,0,1

  # 4d vector Constants -------------------------------
  # zero
  zero4f : new vec4f()
  # one
  one4f : new vec4f(1,1,1,1)
  # x, y, z, w
  x4f : new vec4f(1, 0, 0, 0)
  y4f : new vec4f(0, 1, 0, 0)
  z4f : new vec4f(0, 0, 1, 0)
  w4f : new vec4f(0, 0, 0, 1)

  # 2d integer vector Constants -------------------------------
  # zero
  zero2i : new vec2i
  # one
  one2i : new vec2i 1,1

  # 3d integer vector Constants -------------------------------
  # zero
  zero3i : new vec3i
  # one
  one3i : new vec3i 1,1,1

  # 4d integer vector Constants -------------------------------
  # zero
  zero4i : new vec4i
  # one
  one4i : new vec4i 1,1,1,1

  # 2d, 3d, 4d & 2d, 3d, 4d integer & mat4f component-wise equality  -----------------------
  equal : (a,b) ->
    # 2d
    if a instanceof vec2f and b instanceof vec2f then a.x==b.x and a.y==b.y
      # 3d
    else if a instanceof vec3f and b instanceof vec3f then a.x==b.x and a.y==b.y and a.z==b.z
      # 4d
    else if a instanceof vec4f and b instanceof vec4f then a.x==b.x and a.y==b.y and a.z==b.z and a.w==b.w
      # 2i
    else if a instanceof vec2i and b instanceof vec2i then a.x==b.x and a.y==b.y
      # 3i
    else if a instanceof vec3i and b instanceof vec3i then a.x==b.x and a.y==b.y and a.z==b.z
      # 4i
    else if a instanceof vec4i and b instanceof vec4i then a.x==b.x and a.y==b.y and a.z==b.z and a.w==b.w
      # frame3f
    else if a instanceof frame3f and b instanceof frame3f then equal(a.o,b.o) and equal(a.x,b.x) and equal(a.y,b.y) and equal(a.z,b.z)
      # mat4f
    else if a instanceof mat4f and b instanceof mat4f then equal(a.x,b.x) and equal(a.y,b.y) and equal(a.z,b.z) and equal(a.w,b.w)
      # 1d component-wise equality  -----------------------
    else if a instanceof range1f and b instanceof range1f then return a.min==b.min and a.max==b.max
      # 3d component-wise equality  -----------------------
    else if a instanceof range3f and b instanceof range3f then return equal(a.min,b.min) and equal(a.max,b.max)
      # error
    else alert "Error in function equal"

  # 2d, 3d, 4d & 2d, 3d, 4d integer & mat4f component-wise arithmetic operators -----------
  sum : (a,b) ->
    # 2d
    if a instanceof vec2f and b instanceof vec2f then new vec2f a.x+b.x, a.y+b.y
      # 3d
    else if a instanceof vec3f and b instanceof vec3f then new vec3f a.x+b.x, a.y+b.y, a.z+b.z
      # 4d
    else if a instanceof vec4f and b instanceof vec4f then new vec4f a.x+b.x, a.y+b.y, a.z+b.z, a.w+b.w
      # 2i
    else if a instanceof vec2i and b instanceof vec2i then new vec2i a.x+b.x, a.y+b.y
      # 3i
    else if a instanceof vec3i and b instanceof vec3i then new vec3i a.x+b.x, a.y+b.y, a.z+b.z
      # 4i
    else if a instanceof vec4i and b instanceof vec4i then new vec4i a.x+b.x, a.y+b.y, a.z+b.z, a.w+b.w
      # mat4f
    else if a instanceof mat4f and b instanceof mat4f then new mat4f sum(a.x,b.x), sum(a.y,b.y), sum(a.z,b.z), sum(a.w,b.w)
      # error
    else alert "Error in function sum"
  sub : (a,b) ->
    # 2d
    if a instanceof vec2f and b instanceof vec2f then new vec2f a.x-b.x, a.y-b.y
      # 3d
    else if a instanceof vec3f and b instanceof vec3f then new vec3f a.x-b.x, a.y-b.y, a.z-b.z
      # 4d
    else if a instanceof vec4f and b instanceof vec4f then new vec4f a.x-b.x, a.y-b.y, a.z-b.z, a.w-b.w
      # 2i
    else if a instanceof vec2i and b instanceof vec2i then new vec2i a.x-b.x, a.y-b.y
      # 3i
    else if a instanceof vec3i and b instanceof vec3i then new vec3i a.x-b.x, a.y-b.y, a.z-b.z
      # 4i
    else if a instanceof vec4i and b instanceof vec4i then new vec4i a.x-b.x, a.y-b.y, a.z-b.z, a.w-b.w
      # mat4f
    else if a instanceof mat4f and b instanceof mat4f then new mat4f sub(a.x,b.x), sub(a.y,b.y), sub(a.z,b.z), sub(a.w,b.w)
      # error
    else alert "Error in function sub"
  mul : (a,b) ->
    # 2d * 2d
    if a instanceof vec2f and b instanceof vec2f then new vec2f a.x*b.x, a.y*b.y # vec2f multiplication
      # 2d * c
    else if a instanceof vec2f and typeof b is "number" then new vec2f a.x*b, a.y*b # b is a constant
    else if typeof a is "number" and b instanceof vec2f then new vec2f b.x*a, b.y*a # a is a constant
      # 3d * 3d
    else if a instanceof vec3f and b instanceof vec3f then new vec3f a.x*b.x, a.y*b.y, a.z*b.z # vec3f multiplication
      # 3d * c
    else if a instanceof vec3f and typeof b is "number" then new vec3f a.x*b, a.y*b, a.z*b # b is a constant
    else if typeof a is "number" and b instanceof vec3f then new vec3f b.x*a, b.y*a, b.z*a # a is a constant
      # 4d * 4d
    else if a instanceof vec4f and b instanceof vec4f then new vec4f a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w # vec4f multiplication
      # 4d * c
    else if a instanceof vec4f and typeof b is "number" then new vec4f a.x*b, a.y*b, a.z*b, a.w*b # b is a constant
    else if typeof a is "number" and b instanceof vec4f then new vec4f b.x*a, b.y*a, b.z*a, b.w*a # a is a constant
      # 2i * 2i
    else if a instanceof vec2i and b instanceof vec2i then new vec2i a.x*b.x, a.y*b.y # vec2i multiplication
      # 2i * c
    else if a instanceof vec2i and typeof b is "number" then new vec2i int(a.x*b), int(a.y*b) # b is a constant
    else if typeof a is "number" and b instanceof vec2i then new vec2i int(b.x*a), int(b.y*a) # a is a constant
      # 3i * 3i
    else if a instanceof vec3i and b instanceof vec3i then new vec3i a.x*b.x, a.y*b.y, a.z*b.z # vec3i multiplication
      # 3i * c
    else if a instanceof vec3i and typeof b is "number" then new vec3i int(a.x*b), int(a.y*b), int(a.z*b) # b is a constant
    else if typeof a is "number" and b instanceof vec3i then new vec3i int(b.x*a), int(b.y*a), int(b.z*a) # a is a constant
      # 4i * 4i
    else if a instanceof vec4i and b instanceof vec4i then new vec4i a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w # vec4i multiplication
      # 4i * c
    else if a instanceof vec4i and typeof b is "number" then new vec4i int(a.x*b), int(a.y*b), int(a.z*b), int(a.w*b) # b is a constant
    else if typeof a is "number" and b instanceof vec4i then new vec4i int(b.x*a), int(b.y*a), int(b.z*a), int(b.w*a) # a is a constant
      # mat4f * mat4f
    else if a instanceof mat4f and b instanceof mat4f
      new mat4f(a.x.x*b.x.x+a.x.y*b.y.x+a.x.z*b.z.x+a.x.w*b.w.x , a.x.x*b.x.y+a.x.y*b.y.y+a.x.z*b.z.y+a.x.w*b.w.y , a.x.x*b.x.z+a.x.y*b.y.z+a.x.z*b.z.z+a.x.w*b.w.z , a.x.x*b.x.w+a.x.y*b.y.w+a.x.z*b.z.w+a.x.w*b.w.w  , a.y.x*b.x.x+a.y.y*b.y.x+a.y.z*b.z.x+a.y.w*b.w.x , a.y.x*b.x.y+a.y.y*b.y.y+a.y.z*b.z.y+a.y.w*b.w.y , a.y.x*b.x.z+a.y.y*b.y.z+a.y.z*b.z.z+a.y.w*b.w.z , a.y.x*b.x.w+a.y.y*b.y.w+a.y.z*b.z.w+a.y.w*b.w.w  , a.z.x*b.x.x+a.z.y*b.y.x+a.z.z*b.z.x+a.z.w*b.w.x , a.z.x*b.x.y+a.z.y*b.y.y+a.z.z*b.z.y+a.z.w*b.w.y , a.z.x*b.x.z+a.z.y*b.y.z+a.z.z*b.z.z+a.z.w*b.w.z , a.z.x*b.x.w+a.z.y*b.y.w+a.z.z*b.z.w+a.z.w*b.w.w  , a.w.x*b.x.x+a.w.y*b.y.x+a.w.z*b.z.x+a.w.w*b.w.x , a.w.x*b.x.y+a.w.y*b.y.y+a.w.z*b.z.y+a.w.w*b.w.y , a.w.x*b.x.z+a.w.y*b.y.z+a.w.z*b.z.z+a.w.w*b.w.z , a.w.x*b.x.w+a.w.y*b.y.w+a.w.z*b.z.w+a.w.w*b.w.w  ) # mat4f multiplication
      # mat4f * vec4f
    else if a instanceof mat4f and b instanceof vec4f
      new vec4f(dot(a.x,b),dot(a.y,b),dot(a.z,b),dot(a.w,b)) # b is a vector 4d
      # mat4f * c
    else if a instanceof mat4f and typeof b is "number" then new mat4f mul(a.x,b), mul(a.y,b), mul(a.z,b), mul(a.w,b) # b is a constant
    else if typeof a is "number" and b instanceof mat4f then new mat4f mul(b.x,a), mul(b.y,a), mul(b.z,a), mul(b.w,a) # a is a constant
      # error
    else alert "Error in function mul"
  div : (a,b) ->
    # 2d / 2d
    if a instanceof vec2f and b instanceof vec2f then new vec2f a.x/b.x, a.y/b.y # vec2f division
      # 2d / c
    else if a instanceof vec2f and typeof b is "number" then new vec2f a.x/b, a.y/b # b is a constant
    else if typeof a is "number" and b instanceof vec2f then new vec2f b.x/a, b.y/a # a is a constant
      # 3d / 3d
    else if a instanceof vec3f and b instanceof vec3f then new vec3f a.x/b.x, a.y/b.y, a.z/b.z # vec3f division
      # 3d / c
    else if a instanceof vec3f and typeof b is "number" then new vec3f a.x/b, a.y/b, a.z/b # b is a constant
    else if typeof a is "number" and b instanceof vec3f then new vec3f b.x/a, b.y/a, b.z/a # a is a constant
      # 4d / 4d
    else if a instanceof vec4f and b instanceof vec4f then new vec4f a.x/b.x, a.y/b.y, a.z/b.z, a.w/b.w # vec4f division
      # 4d / c
    else if a instanceof vec4f and typeof b is "number" then new vec4f a.x/b, a.y/b, a.z/b, a.w/b # b is a constant
    else if typeof a is "number" and b instanceof vec4f then new vec4f b.x/a, b.y/a, b.z/a, b.w/a # a is a constant
      # 2i / 2i
    else if a instanceof vec2i and b instanceof vec2i then new vec2i a.x//b.x, a.y//b.y # vec2i division
      # 2i / c
    else if a instanceof vec2i and typeof b is "number" then new vec2i a.x//b, a.y//b # b is a constant
    else if typeof a is "number" and b instanceof vec2i then new vec2i b.x//a, b.y//a # a is a constant
      # 3i / 3i
    else if a instanceof vec3i and b instanceof vec3i then new vec3i a.x//b.x, a.y//b.y, a.z//b.z # vec3i division
      # 3i / c
    else if a instanceof vec3i and typeof b is "number" then new vec3i a.x//b, a.y//b, a.z//b # b is a constant
    else if typeof a is "number" and b instanceof vec3i then new vec3i b.x//a, b.y//a, b.z//a # a is a constant
      # 4i / 4i
    else if a instanceof vec4i and b instanceof vec4i then new vec4i a.x//b.x, a.y//b.y, a.z//b.z, a.w//b.w # vec4i division
      # 4i / c
    else if a instanceof vec4i and typeof b is "number" then new vec4i a.x//b, a.y//b, a.z//b, a.w//b # b is a constant
    else if typeof a is "number" and b instanceof vec4i then new vec4i b.x//a, b.y//a, b.z//a, b.w//a # a is a constant
      # mat4f * c
    else if a instanceof mat4f and typeof b is "number" then new mat4f div(a.x,b), div(a.y,b), div(a.z,b), div(a.w,b) # b is a constant
    else if typeof a is "number" and b instanceof mat4f then new mat4f div(b.x,a), div(b.y,a), div(b.z,a), div(b.w,a) # a is a constant
      # error
    else alert "Error in function div"

  # 2d & 3d component-wise functions ----------------------
  # max, min, clamp
  max : (a,b) ->
    # math utilities
    if typeof a is "number" and typeof b is "number"
      if a > b then a else b
      # 2d
    else if a instanceof vec2f and b instanceof vec2f then new vec2f max(a.x,b.x), max(a.y,b.y)
    else if a instanceof vec2f and typeof b is "number" then new vec2f max(a.x,b), max(a.y,b) # b is a constant
    else if typeof a is "number" and b instanceof vec2f then new vec2f max(a,b.x), max(a,b.x) # a is a constant
      # 3d
    else if a instanceof vec3f and b instanceof vec3f then new vec3f max(a.x,b.x), max(a.y,b.y), max(a.z,b.z)
    else if a instanceof vec3f and typeof b is "number" then new vec3f max(a.x,b), max(a.y,b), max(a.z,b) # b is a constant
    else if typeof a is "number" and b instanceof vec3f then new vec3f max(a,b.x), max(a,b.x), max(a,b.z) # a is a constant
      # 4d
    else if a instanceof vec4f and b instanceof vec4f then new vec4f max(a.x,b.x), max(a.y,b.y), max(a.z,b.z), max(a.w,b.w)
    else if a instanceof vec4f and typeof b is "number" then new vec4f max(a.x,b), max(a.y,b), max(a.z,b), max(a.w,b) # b is a constant
    else if typeof a is "number" and b instanceof vec4f then new vec4f max(a,b.x), max(a,b.x), max(a,b.z), max(a,b.w) # a is a constant
      # 2i
    else if a instanceof vec2i and b instanceof vec2i then new vec2i max(a.x,b.x), max(a.y,b.y)
    else if a instanceof vec2i and typeof b is "number" then new vec2i max(a.x,b), max(a.y,b) # b is a constant
    else if typeof a is "number" and b instanceof vec2i then new vec2i max(a,b.x), max(a,b.x) # a is a constant
      # 3i
    else if a instanceof vec3i and b instanceof vec3i then new vec3i max(a.x,b.x), max(a.y,b.y), max(a.z,b.z)
    else if a instanceof vec3i and typeof b is "number" then new vec3i max(a.x,b), max(a.y,b), max(a.z,b) # b is a constant
    else if typeof a is "number" and b instanceof vec3i then new vec3i max(a,b.x), max(a,b.x), max(a,b.z) # a is a constant
      # 4i
    else if a instanceof vec4i and b instanceof vec4i then new vec4i max(a.x,b.x), max(a.y,b.y), max(a.z,b.z), max(a.w,b.w)
    else if a instanceof vec4i and typeof b is "number" then new vec4i max(a.x,b), max(a.y,b), max(a.z,b), max(a.w,b) # b is a constant
    else if typeof a is "number" and b instanceof vec4i then new vec4i max(a,b.x), max(a,b.x), max(a,b.z), max(a,b.w) # a is a constant

  min : (a,b) ->
    # math utilities
    if typeof a is "number" and typeof b is "number"
      if a < b then a else b
    # 2d
    if a instanceof vec2f and b instanceof vec2f then new vec2f min(a.x,b.x), min(a.y,b.y)
    else if a instanceof vec2f and typeof b is "number" then new vec2f min(a.x,b), min(a.y,b) # b is a constant
    else if typeof a is "number" and b instanceof vec2f then new vec2f min(a,b.x), min(a,b.x) # a is a constant
      # 3d
    else if a instanceof vec3f and b instanceof vec3f then new vec3f min(a.x,b.x), min(a.y,b.y), min(a.z,b.z)
    else if a instanceof vec3f and typeof b is "number" then new vec3f min(a.x,b), min(a.y,b), min(a.z,b) # b is a constant
    else if typeof a is "number" and b instanceof vec3f then new vec3f min(a,b.x), min(a,b.x), min(a,b.z) # a is a constant
      # 4d
    else if a instanceof vec4f and b instanceof vec4f then new vec4f min(a.x,b.x), min(a.y,b.y), min(a.z,b.z), min(a.w,b.w)
    else if a instanceof vec4f and typeof b is "number" then new vec4f min(a.x,b), min(a.y,b), min(a.z,b), min(a.w,b) # b is a constant
    else if typeof a is "number" and b instanceof vec4f then new vec4f min(a,b.x), min(a,b.x), min(a,b.z), min(a,b.w) # a is a constant
      # 2i
    else if a instanceof vec2i and b instanceof vec2i then new vec2i min(a.x,b.x), min(a.y,b.y)
    else if a instanceof vec2i and typeof b is "number" then new vec2i min(a.x,b), min(a.y,b) # b is a constant
    else if typeof a is "number" and b instanceof vec2i then new vec2i min(a,b.x), min(a,b.x) # a is a constant
      # 3i
    else if a instanceof vec3i and b instanceof vec3i then new vec3i min(a.x,b.x), min(a.y,b.y), min(a.z,b.z)
    else if a instanceof vec3i and typeof b is "number" then new vec3i min(a.x,b), min(a.y,b), min(a.z,b) # b is a constant
    else if typeof a is "number" and b instanceof vec3i then new vec3i min(a,b.x), min(a,b.x), min(a,b.z) # a is a constant
      # 4i
    else if a instanceof vec4i and b instanceof vec4i then new vec4i min(a.x,b.x), min(a.y,b.y), min(a.z,b.z), min(a.w,b.w)
    else if a instanceof vec4i and typeof b is "number" then new vec4i min(a.x,b), min(a.y,b), min(a.z,b), min(a.w,b) # b is a constant
    else if typeof a is "number" and b instanceof vec4i then new vec4i min(a,b.x), min(a,b.x), min(a,b.z), min(a,b.w) # a is a constant
  # clamp (sets x between m and M)
  clamp : (x,m,M) ->
    # math utilities
    if typeof x is "number" and typeof m is "number" and typeof M is "number"
      return min(M,max(m,x))
    # 2d
    if x instanceof vec2f and m instanceof vec2f and M instanceof vec2f then new vec2f clamp(x.x,m.x,M.x), clamp(x.y,m.y,M.y)
    else if x instanceof vec2f and typeof m is "number" and typeof M is "number" then new vec2f clamp(x.x,m,M), clamp(x.y,m,M) # m and M are constants
      # 3d
    else if x instanceof vec3f and m instanceof vec3f and M instanceof vec3f then new vec3f clamp(x.x,m.x,M.x), clamp(x.y,m.y,M.y), clamp(x.z,m.z,M.z)
    else if x instanceof vec3f and typeof m is "number" and typeof M is "number" then new vec3f clamp(x.x,m,M), clamp(x.y,m,M), clamp(x.z,m,M) # m and M are constants
      # 4d
    else if x instanceof vec4f and m instanceof vec4f and M instanceof vec4f then new vec4f clamp(x.x,m.x,M.x), clamp(x.y,m.y,M.y), clamp(x.z,m.z,M.z), clamp(x.w,m.w,M.w)
    else if x instanceof vec4f and typeof m is "number" and typeof M is "number" then new vec4f clamp(x.x,m,M), clamp(x.y,m,M), clamp(x.z,m,M), clamp(x.w,m,M) # m and M are constants
      # 2i
    else if x instanceof vec2i and m instanceof vec2i and M instanceof vec2i then new vec2i clamp(x.x,m.x,M.x), clamp(x.y,m.y,M.y)
    else if x instanceof vec2i and typeof m is "number" and typeof M is "number" then new vec2i clamp(x.x,m,M), clamp(x.y,m,M) # m and M are constants
      # 3i
    else if x instanceof vec3i and m instanceof vec3i and M instanceof vec3i then new vec3i clamp(x.x,m.x,M.x), clamp(x.y,m.y,M.y), clamp(x.z,m.z,M.z)
    else if x instanceof vec3i and typeof m is "number" and typeof M is "number" then new vec3i clamp(x.x,m,M), clamp(x.y,m,M), clamp(x.z,m,M) # m and M are constants
      # 4i
    else if x instanceof vec4i and m instanceof vec4i and M instanceof vec4i then new vec4i clamp(x.x,m.x,M.x), clamp(x.y,m.y,M.y), clamp(x.z,m.z,M.z), clamp(x.w,m.w,M.w)
    else if x instanceof vec4i and typeof m is "number" and typeof M is "number" then new vec4i clamp(x.x,m,M), clamp(x.y,m,M), clamp(x.z,m,M), clamp(x.w,m,M) # m and M are constants

  mean : (a) ->
    # 2d
    if a instanceof vec2f then return (a.x + a.y) / 2
      # 3d
    else if a instanceof vec3f then return (a.x + a.y + a.z) / 3
      # 4d
    else if a instanceof vec4f then return (a.x + a.y + a.z + a.w) / 4

  # 2d, 3d & 4d vector operations -----------------------------
  # dot product
  dot : (a,b) ->
    # 2d
    if a instanceof vec2f and b instanceof vec2f then return a.x*b.x+a.y*b.y
      # 3d
    else if a instanceof vec3f and b instanceof vec3f then return a.x*b.x+a.y*b.y+a.z*b.z
      # 4d
    else if a instanceof vec4f and b instanceof vec4f then return a.x*b.x+a.y*b.y+a.z*b.z+a.w*b.w
  # length and lengthSqr
  length : (a) -> if a instanceof vec2f or a instanceof vec3f or a instanceof vec4f then return Math.sqrt(dot(a,a))
  lengthSqr : (a) -> if a instanceof vec2f or a instanceof vec3f or a instanceof vec4f then return dot(a,a)
  # normalize
  normalize : (a) ->
    # 2d
    if a instanceof vec2f
      l = length(a)
      if l is 0 then return new vec2f else mul(a, 1/l)
      # 3d
    else if a instanceof vec3f
      l = length(a)
      if l is 0 then return new vec3f else mul(a, 1/l)
      # 4d
    else if a instanceof vec4f
      l = length(a)
      if l is 0 then return new vec4f else mul(a, 1/l)
  # 3d & 4d component-wise functions ----------------------
  # pow, sqrt, exp
  pow : (a,b) ->
    # 3d
    if a instanceof vec3f and typeof b is "number" then new vec3f pow(a.x,b), pow(a.y,b), pow(a.z,b)
      # 4d
    else if a instanceof vec4f and typeof b is "number" then new vec4f pow(a.x,b), pow(a.y,b), pow(a.z,b), pow(a.w,b)
  sqrt : (a) ->
    # 3d
    if a instanceof vec3f then new vec3f Math.sqrt(a.x), Math.sqrt(a.y), Math.sqrt(a.z)
    else if a instanceof vec4f then new vec4f Math.sqrt(a.x), Math.sqrt(a.y), Math.sqrt(a.z), Math.sqrt(a.w)
  exp : (a) ->
    if a instanceof vec3f then new vec3f Math.exp(a.x), Math.exp(a.y), Math.exp(a.z)
    else if a instanceof vec4f then new vec4f Math.exp(a.x), Math.exp(a.y), Math.exp(a.z), Math.exp(a.w)

  # 3d vector operations -----------------------------
  # distance and diatcne squared
  dist : (a,b) -> if a instanceof vec3f and b instanceof vec3f then return length(sub a,b)
  distSqr : (a,b) -> if a instanceof vec3f and b instanceof vec3f then return lengthSqr(sub a,b)
  # cross product
  cross : (a,b) -> if a instanceof vec3f and b instanceof vec3f then return new vec3f a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x
  # orthonormalization in the given order
  orthonormalize_zyx : (x,y,z) ->
    if x instanceof vec3f and y instanceof vec3f and z instanceof vec3f
      z = normalize(z)
      x = normalize(cross y, z)
      y = normalize(cross z, x)
      # orthonormalize frame basis in the given order
    else if x instanceof frame3f
      ret = x.clone()
      orthonormalize_zyx(ret.x,ret.y,ret.z)
      return ret
  orthonormalize_zxy : (x,y,z) ->
    if x instanceof vec3f and y instanceof vec3f and z instanceof vec3f
      z = normalize(z)
      y = normalize(cross z, x)
      x = normalize(cross y, z)
      # orthonormalize frame basis in the given order
    else if x instanceof frame3f
      ret = x.clone()
      orthonormalize_zyx(ret.x,ret.y,ret.z)
      return ret
  orthonormalize_xzy : (x,y,z) ->
    if x instanceof vec3f and y instanceof vec3f and z instanceof vec3f
      x = normalize(x)
      x = normalize(cross z, x)
      y = normalize(cross x, y)
      # orthonormalize frame basis in the given order
    else if x instanceof frame3f
      ret = x.clone()
      orthonormalize_xzy(ret.x,ret.y,ret.z)
      return ret
  # direction of mirror reflection of v with normal n (v is incoming)
  reflect : (v,n) -> if v instanceof vec3f and n instanceof vec3f then sub(v, mul(n, 2 * dot(n,v)))
  # direction of refraction of v with normal n (v is incoming --- from glsl documentation)
  refract : (v, n, eta) ->
    if v instanceof vec3f and n instanceof vec3f and typeof eta is "number"
      k = 1 - eta * eta * (1 - dot(n,v)) * dot(n,v)
      return if k < 0 then new vec3f else sub( mul(eta,v) , mul(n , eta * dot(n,v) + Math.sqrt(k)) )

  # 3d integer component-wise functions ----------------------
  # max_component
  max_component : (a) ->
    if a instanceof vec3i
      r = a.x
      r = max(r,a.x)
      r = max(r,a.y)
      r = max(r,a.z)
      return r
  # min_component
  min_component : (a) ->
    if a instanceof vec3i
      r = a.x
      r = min(r,a.x)
      r = min(r,a.y)
      r = min(r,a.z)
      return r

  # frames constants ----------------------------------
  # identity frame
  identity_frame3f : new frame3f()

  # frames vector operations -------------------------
  # inverse of a frame
  inverse : (f) -> if f instanceof frame3f
    new frame3f(new vec3f(-dot(f.o,f.x), -dot(f.o,f.y), -dot(f.o,f.z)), new vec3f(f.x.x, f.y.x, f.z.x), new vec3f(f.x.y, f.y.y, f.z.y), new vec3f(f.x.z, f.y.z, f.z.z))
  # creates a frame from z
  frame_from_z : (z) ->
    if z instanceof vec3f
      f = identity_frame3f.clone()
      f.z = normalize(z)
      f.y = if Math.abs(dot(y3f,z)) > 0.95 then x3f.clone() else y3f.clone()
      return orthonormalize_zyx(f)

  # frames creation ----------------------------------
  # frame at eye that looks at center with vertical orientation as up (flipped changes z direction)
  lookat_frame : (eye, center, up, flipped = false) ->
    if eye instanceof vec3f and center instanceof vec3f and up instanceof vec3f and typeof flipped is "boolean"
      f = new frame3f()
      f.o = eye.clone()
      f.z = normalize(sub(center,eye))
      if flipped then f.z = f.z.opposite()
      f.y = up.clone()
      f = orthonormalize_zyx(f)
      return f

  # frame-element transforms -------------------------
  # matrix-element transforms ------------------------
  # transform a point by a frame
  transform_point : (f,v) ->
    if f instanceof frame3f and v instanceof vec3f
      ret = f.o.clone()
      ret.sum(mul(f.x,v.x))
      ret.sum(mul(f.y,v.y))
      ret.sum(mul(f.z,v.z))
      return ret
      # transform a point by a matrix
    else if f instanceof mat4f and v instanceof vec3f
      tv = mul(f,new vec4f(v.x,v.y,v.z,1))
      return div(new vec3f(tv.x,tv.y,tv.z), tv.w)
  # transform a vector by a frame
  transform_vector : (f,v) ->
    if f instanceof frame3f and v instanceof vec3f
      ret = mul(f.x,v.x)
      ret.sum(mul(f.y,v.y))
      ret.sum(mul(f.z,v.z))
      return ret
      # transform a vector by a matrix
    else if f instanceof mat4f and v instanceof vec3f
      tv = mul(f,new vec4f(v.x,v.y,v.z,0))
    return new vec3f(tv.x,tv.y,tv.z)
  # transform a vector by a direciton
  transform_direction : (f,v) ->
    if f instanceof frame3f and v instanceof vec3f
      return transform_vector(f,v)
      # transform a matrix by a direciton
    else if f instanceof mat4f and v instanceof vec3f
      return normalize(transform_vector(f,v))
  # transform a normal by a frame
  transform_normal : (f,v) ->
    if f instanceof frame3f and v instanceof vec3f
      return transform_vector(f,v)
      # transform a normal by a matrix
    else if f instanceof mat4f and v instanceof vec3f
      return normalize(transform_vector(f,v))
  # transform a frame by a frame
  transform_frame : (f,v) ->
    if f instanceof frame3f and v instanceof vec3f
      new frame3f(transform_point(f,v.o), transform_vector(f,v.x), transform_vector(f,v.y), transform_vector(f,v.z))
      # transform a frame by a matrix
    else if f instanceof mat4f and v instanceof vec3f
      ret = new frame3f()
      ret.o = transform_point(f,v.o);
      ret.x = transform_direction(f,v.x)
      ret.y = transform_direction(f,v.y)
      ret.z = cross(ret.x,ret.y)
      ret = orthonormalize_zyx(ret)
      return ret
  # frame-element inverse transforms ------------------
  # transform a point by a frame inverse
  transform_point_inverse : (f,v) -> if f instanceof frame3f and v instanceof vec3f
    new vec3f(dot(sub(v,f.o),f.x), dot(sub(v,f.o),f.y), dot(sub(v,f.o),f.z))
  # transform a vector by a frame inverse
  transform_vector_inverse : (f,v) -> if f instanceof frame3f and v instanceof vec3f
    new vec3f(dot(v,f.x), dot(v,f.y), dot(v,f.z))
  # transform a direction by a frame inverse
  transform_direction_inverse : (f,v) -> if f instanceof frame3f and v instanceof vec3f
    return transform_vector_inverse(f,v)
  # transform a normal by a frame inverse
  transform_normal_inverse : (f,v) -> if f instanceof frame3f and v instanceof vec3f
    return transform_vector_inverse(f,v)
  # transform a frame by a frame inverse
  transform_frame_inverse : (f,v) -> if f instanceof frame3f and v instanceof vec3f
    return new frame3f(transform_point_inverse(f,v.o), transform_vector_inverse(f,v.x), transform_vector_inverse(f,v.y), transform_vector_inverse(f,v.z))

  # matrix constants ----------------------------------
  # identity matrix
  identity_mat4f : new mat4f()

  # 4x4 matrix operations ----------------------------
  transpose : (a) -> if a instanceof mat4f
    new mat4f(a.x.x, a.y.x, a.z.x, a.w.x , a.x.y, a.y.y, a.z.y, a.w.y , a.x.z, a.y.z, a.z.z, a.w.z , a.x.w, a.y.w, a.z.w, a.w.w )
  determinant : (a) -> if a instanceof mat4f
    return +a.x.x*(+a.y.y*(a.z.z*a.w.w-a.z.w*a.w.z)-a.y.z*(a.z.y*a.w.w-a.z.w*a.w.y)+a.y.w*(a.z.y*a.w.z-a.z.z*a.w.y))-a.x.y*(+a.y.x*(a.z.z*a.w.w-a.z.w*a.w.z)-a.y.z*(a.z.x*a.w.w-a.z.w*a.w.x)+a.y.w*(a.z.x*a.w.z-a.z.z*a.w.x))+a.x.z*(+a.y.x*(a.z.y*a.w.w-a.z.w*a.w.y)-a.y.y*(a.z.x*a.w.w-a.z.w*a.w.x)+a.y.w*(a.z.x*a.w.y-a.z.y*a.w.x))-a.x.w*(+a.y.x*(a.z.y*a.w.z-a.z.z*a.w.y)-a.y.y*(a.z.x*a.w.z-a.z.z*a.w.x)+a.y.z*(a.z.x*a.w.y-a.z.y*a.w.x))
  inverse : (a) ->
    if a instanceof mat4f
      d = determinant(a)
      di = 1/d
      ret = new mat4f(+(+a.y.y*(a.z.z*a.w.w-a.z.w*a.w.z)-a.y.z*(a.z.y*a.w.w-a.z.w*a.w.y)+a.y.w*(a.z.y*a.w.z-a.z.z*a.w.y)), -(+a.x.y*(a.z.z*a.w.w-a.z.w*a.w.z)-a.x.z*(a.z.y*a.w.w-a.z.w*a.w.y)+a.x.w*(a.z.y*a.w.z-a.z.z*a.w.y)), +(+a.x.y*(a.y.z*a.w.w-a.y.w*a.w.z)-a.x.z*(a.y.y*a.w.w-a.y.w*a.w.y)+a.x.w*(a.y.y*a.w.z-a.y.z*a.w.y)), -(+a.x.y*(a.y.z*a.z.w-a.y.w*a.z.z)-a.x.z*(a.y.y*a.z.w-a.y.w*a.z.y)+a.x.w*(a.y.y*a.z.z-a.y.z*a.z.y)), -(+a.y.x*(a.z.z*a.w.w-a.z.w*a.w.z)-a.y.z*(a.z.x*a.w.w-a.z.w*a.w.x)+a.y.w*(a.z.x*a.w.z-a.z.z*a.w.x)), +(+a.x.x*(a.z.z*a.w.w-a.z.w*a.w.z)-a.x.z*(a.z.x*a.w.w-a.z.w*a.w.x)+a.x.w*(a.z.x*a.w.z-a.z.z*a.w.x)), -(+a.x.x*(a.y.z*a.w.w-a.y.w*a.w.z)-a.x.z*(a.y.x*a.w.w-a.y.w*a.w.x)+a.x.w*(a.y.x*a.w.z-a.y.z*a.w.x)), +(+a.x.x*(a.y.z*a.z.w-a.y.w*a.z.z)-a.x.z*(a.y.x*a.z.w-a.y.w*a.z.x)+a.x.w*(a.y.x*a.z.z-a.y.z*a.z.x)), +(+a.y.x*(a.z.y*a.w.w-a.z.w*a.w.y)-a.y.y*(a.z.x*a.w.w-a.z.w*a.w.x)+a.y.w*(a.z.x*a.w.y-a.z.y*a.w.x)), -(+a.x.x*(a.z.y*a.w.w-a.z.w*a.w.y)-a.x.y*(a.z.x*a.w.w-a.z.w*a.w.x)+a.x.w*(a.z.x*a.w.y-a.z.y*a.w.x)), +(+a.x.x*(a.y.y*a.w.w-a.y.w*a.w.y)-a.x.y*(a.y.x*a.w.w-a.y.w*a.w.x)+a.x.w*(a.y.x*a.w.y-a.y.y*a.w.x)), -(+a.x.x*(a.y.y*a.z.w-a.y.w*a.z.y)-a.x.y*(a.y.x*a.z.w-a.y.w*a.z.x)+a.x.w*(a.y.x*a.z.y-a.y.y*a.z.x)), -(+a.y.x*(a.z.y*a.w.z-a.z.z*a.w.y)-a.y.y*(a.z.x*a.w.z-a.z.z*a.w.x)+a.y.z*(a.z.x*a.w.y-a.z.y*a.w.x)), +(+a.x.x*(a.z.y*a.w.z-a.z.z*a.w.y)-a.x.y*(a.z.x*a.w.z-a.z.z*a.w.x)+a.x.z*(a.z.x*a.w.y-a.z.y*a.w.x)), -(+a.x.x*(a.y.y*a.w.z-a.y.z*a.w.y)-a.x.y*(a.y.x*a.w.z-a.y.z*a.w.x)+a.x.z*(a.y.x*a.w.y-a.y.y*a.w.x)), +(+a.x.x*(a.y.y*a.z.z-a.y.z*a.z.y)-a.x.y*(a.y.x*a.z.z-a.y.z*a.z.x)+a.x.z*(a.y.x*a.z.y-a.y.y*a.z.x)))
      return ret.mul(di)

  # transform tests ----------------------------------
  # tests whether a matrix is affine (approximately)
  isaffine : (m) -> if m instanceof mat4f
    return m.w.x==0 and m.w.y==0 and m.w.z==0 and m.w.w==1

  # transform matrices -------------------------------
  # translation matrix
  translation_matrix : (t) -> if t instanceof vec3f
    return new mat4f(1,0,0,t.x,  0,1,0,t.y,  0,0,1,t.z,  0,0,0,1)
  # rotation matrix
  rotation_matrix : (angle,axis) ->
    if typeof angle is "numeric" and axis instanceof vec3f
      c = Math.cos(angle)
      s = Math.sin(angle)
      vv = normalize(axis)
      return new mat4f(c + (1-c)*vv.x*vv.x, (1-c)*vv.x*vv.y - s*vv.z, (1-c)*vv.x*vv.z + s*vv.y, 0,  (1-c)*vv.x*vv.y + s*vv.z, c + (1-c)*vv.y*vv.y, (1-c)*vv.y*vv.z - s*vv.x, 0,  (1-c)*vv.x*vv.z - s*vv.y, (1-c)*vv.y*vv.z + s*vv.x, c + (1-c)*vv.z*vv.z, 0,  0,0,0,1)
  # scaling matrix
  scaling_matrix : (s) -> if s instanceof vec3f
    return new mat4f(s.x,0,0,0,  0,s.y,0,0,  0,0,s.z,0,  0,0,0,1)
  # opengl frustum matrix
  frustum_matrix : (l,r,b,t,n,f) -> if typeof l is "numeric" and typeof r is "numeric" and typeof b is "numeric" and typeof t is "numeric" and typeof n is "numeric" and typeof f is "numeric"
    return new mat4f(2*n/(r-l), 0, (r+l)/(r-l), 0,  0, 2*n/(t-b), (t+b)/(t-b), 0,  0, 0, -(f+n)/(f-n), -2*f*n/(f-n), 0, 0, -1, 0)
  # opengl ortho matrix
  ortho_matrix : (l,r,b,t,n,f) -> if typeof l is "numeric" and typeof r is "numeric" and typeof b is "numeric" and typeof t is "numeric" and typeof n is "numeric" and typeof f is "numeric"
    return new mat4f(2/(r-l), 0, 0, -(r+l)/(r-l),  0, 2/(t-b), 0, -(t+b)/(t-b),  0, 0, -2/(f-n), -(f+n)/(f-n), 0, 0, 0, 1)

  # lookat matrix
  lookat_matrix: (eye,center,up) ->
    if eye instanceof vec3f and center instanceof vec3f and up instanceof vec3f
      w = normalize(sub(eye, center))
      u = normalize(cross(up,w))
      v = cross(w,u)
      return new mat4f(u.x, u.y, u.z, -dot(u,eye),  v.x, v.y, v.z, -dot(v,eye),  w.x, w.y, w.z, -dot(w,eye),  0, 0, 0, 1)
  # opengl glu ortho2d matrix
  ortho2d_matrix : (l,r,b,t) -> if typeof l is "numeric" and typeof r is "numeric" and typeof b is "numeric" and typeof t is "numeric"
    return ortho_matrix(l,r,b,t,-1,1)
  # opengl glu perspective matrix
  perspective_matrix : (fovy,aspect,near,far) ->
    if typeof fovy is "numeric" and typeof aspect is "numeric" and typeof near is "numeric" and typeof far is "numeric"
      f = 1/tan(fovy/2)
      return new mat4f(f/aspect,0,0,0,   0,f,0,0,    0,0,(far+near)/(near-far),2*far*near/(near-far),    0,0,-1,0)

  # frame-matrix conversion --------------------------
  frame_to_matrix : (f) -> if f instanceof frame3f
    return new mat4f(f.x.x, f.y.x, f.z.x,f.o.x, f.x.y, f.y.y, f.z.y,f.o.y, f.x.z, f.y.z, f.z.z,f.o.z, 0,0,0,1)
  frame_to_matrix_inverse : (f) -> if f instanceof frame3f
    return new mat4f(f.x.x, f.x.y, f.x.z, -dot(f.o,f.x), f.y.x, f.y.y, f.y.z, -dot(f.o,f.y), f.z.x, f.z.y, f.z.z, -dot(f.o,f.z), 0,0,0,1)
  matrix_to_frame : (m) ->
    if m instanceof mat4f
      error_if_not(isaffine(m), "not affine")
      f = new frame3f()
      f.o = new vec3f(m.x.w, m.y.w, m.z.w)
      f.x = new vec3f(m.x.x, m.y.x, m.z.x)
      f.y = new vec3f(m.x.y, m.y.y, m.z.y)
      f.z = new vec3f(m.x.z, m.y.z, m.z.z)
      return f

  # 1d bounding & 3d bounding interval operatons  -------------------
  isvalid : (a) ->
    # 1d
    if a instanceof range1f then return min(a.min,a.max) == a.min
      # 3d
    else if a instanceof range3f then return equal(min(a.min,a.max),a.min)
  size : (a) ->
    # 1d
    if a instanceof range1f then return a.max - a.min
      # 3d
    else if a instanceof range3f then return sub(a.max,a.min)
  center : (a) ->
    # 1d
    if a instanceof range1f then return (a.max + a.min) / 2
      # 3d
    else if a instanceof range3f then return div(sum(a.max,a.min), 2)
  runion : (a,b) ->
    # 1d
    if a instanceof range1f and typeof b is "number"
      if(not isvalid(a)) then return new range1f(b,b)
      return new range1f(min(a.min,b),max(a.max,b))
    else if a instanceof range1f and b instanceof range1f
      if(not isvalid(a)) then return b
      if(not isvalid(b)) then return a
      return new range1f(min(a.min,b.min),max(a.max,b.max))
      # 3d
    else if a instanceof range3f and typeof b is "number"
      if(not isvalid(a)) then return new range3f(b,b)
      return range3f(min(a.min,b),max(a.max,b))
    else if a instanceof range3f and b instanceof range3f
      if(not isvalid(a)) then return b
      if(not isvalid(b)) then return a
      return new range3f(min(a.min,b.min),max(a.max,b.max))
  rscale : (a,b) ->
    # 1d
    if a instanceof range1f and typeof b is "number" then return new range1f(center(a)-size(a)*b/2,center(a)+size(a)*b/2)
      # 3d
    else if a instanceof range3f and typeof b is "number" then return new range3f(sub(center(a), mul(size(a), div(b,2))), sum(center(a), mul(size(a), div(b,2))))

  # 3d bounding interval operatons  -------------------
  make_range3f : (points) -> if points instanceof Array
    bbox = new range3f()
    bbox = runion(bbox,p) for p in points
    return bbox
  corners : (a) -> if a instanceof range3f
    return [new vec3f(a.min.x,a.min.y,a.min.z), new vec3f(a.min.x,a.min.y,a.max.z), new vec3f(a.min.x,a.max.y,a.min.z), new vec3f(a.min.x,a.max.y,a.max.z), new vec3f(a.max.x,a.min.y,a.min.z), new vec3f(a.max.x,a.min.y,a.max.z), new vec3f(a.max.x,a.max.y,a.min.z), new vec3f(a.max.x,a.max.y,a.max.z)]

}

# 2d vector
class vec2f
  constructor: (@x = 0, @y = 0) ->
  clone: -> new vec2f(@x,@y)
  # 2d component-wise arithmetic operators -----------
  #   -v
  opposite: -> new vec2f(-@x,-@y)
  #   v += b
  sum: (b) ->
    if b instanceof vec2f
      @x+=b.x
      @y+=b.y
      return @
  #   v -= b
  sub: (b) ->
    if b instanceof vec2f
      @x-=b.x
      @y-=b.y
      return @
  #   v *= b
  mul: (b) ->
    if b instanceof vec2f
      @x*=b.x
      @y*=b.y
      return @
    else if typeof b is "number"
      @x*=b
      @y*=b
      return @
  #   v /= b
  div: (b) ->
    if b instanceof vec2f
      @x/=b.x
      @y/=b.y
      return @
    else if typeof b is "number"
      @x/=b
      @y/=b
      return @

# 3d vector
class vec3f
  constructor: (@x = 0, @y = 0, @z = 0) ->
  clone: -> new vec3f(@x,@y,@z)
  # 3d component-wise arithmetic operators -----------
  #   -v
  opposite: -> new vec3f(-@x,-@y,-@z)
  #   v += b
  sum: (b) ->
    if b instanceof vec3f
      @x+=b.x
      @y+=b.y
      @z+=b.z
      return @
  #   v -= b
  sub: (b) ->
    if b instanceof vec3f
      @x-=b.x
      @y-=b.y
      @z-=b.z
      return @
  #   v *= b
  mul: (b) ->
    if b instanceof vec3f
      @x*=b.x
      @y*=b.y
      @z*=b.z
      return @
    else if typeof b is "number"
      @x*=b
      @y*=b
      @z*=b
      return @
  #   v /= b
  div: (b) ->
    if b instanceof vec3f
      @x/=b.x
      @y/=b.y
      @z/=b.z
      return @
    else if typeof b is "number"
      @x/=b
      @y/=b
      @z/=b
      return @
vmath.vec3f = vec3f

# 4d vector
class vec4f
  constructor: (@x = 0, @y = 0, @z = 0, @w = 0) ->
  clone: -> new vec4f(@x,@y,@z,@w)
  # 4d component-wise arithmetic operators -----------
  #   -v
  opposite: -> new vec4f(-@x,-@y,-@z,-@w)
  #   v += b
  sum: (b) ->
    if b instanceof vec4f
      @x+=b.x
      @y+=b.y
      @z+=b.z
      @w+=b.w
      return @
  #   v -= b
  sub: (b) ->
    if b instanceof vec4f
      @x-=b.x
      @y-=b.y
      @z-=b.z
      @w-=b.w
      return @
  #   v *= b
  mul: (b) ->
    if b instanceof vec4f
      @x*=b.x
      @y*=b.y
      @z*=b.z
      @w*=b.w
      return @
    else if typeof b is "number"
      @x*=b
      @y*=b
      @z*=b
      @w*=b
      return @
  #   v /= b
  div: (b) ->
    if b instanceof vec4f
      @x/=b.x
      @y/=b.y
      @z/=b.z
      @w/=b.w
      return @
    else if typeof b is "number"
      @x/=b
      @y/=b
      @z/=b
      @w/=b
      return @
vmath.vec4f = vec4f

# 2d integer vector
class vec2i
  constructor: (@x = 0, @y = 0) ->
    @x = int @x
    @y = int @y
  clone: -> new vec2i(@x,@y)
  # 2d integer component-wise arithmetic operators -----------
  #   -v
  opposite: -> new vec2i(-@x,-@y)
  #   v += b
  sum: (b) ->
    if b instanceof vec2i
      @x+=b.x
      @y+=b.y
      return @
  #   v -= b
  sub: (b) ->
    if b instanceof vec2i
      @x-=b.x
      @y-=b.y
      return @
  #   v *= b
  mul: (b) ->
    if b instanceof vec2i
      @x*=b.x
      @y*=b.y
      return @
    else if typeof b is "number"
      @x = int(@x*b)
      @y = int(@y*b)
      return @
  #   v /= b
  div: (b) ->
    if b instanceof vec2i
      @x = @x // b.x
      @y = @y // b.y
      return @
    else if typeof b is "number"
      @x = @x // b
      @y = @y // b
      return @
vmath.vec2i = vec2i

# 3d integer vector
class vec3i
  constructor: (@x = 0, @y = 0, @z = 0) ->
    @x = int @x
    @y = int @y
    @z = int @z
  clone: -> new vec3i(@x,@y,@z)
  # 3d integer component-wise arithmetic operators -----------
  #   -v
  opposite: -> new vec3i(-@x,-@y,-@z)
  #   v += b
  sum: (b) ->
    if b instanceof vec3i
      @x+=b.x
      @y+=b.y
      @z+=b.z
      return @
  #   v -= b
  sub: (b) ->
    if b instanceof vec3i
      @x-=b.x
      @y-=b.y
      @z-=b.z
      return @
  #   v *= b
  mul: (b) ->
    if b instanceof vec3i
      @x*=b.x
      @y*=b.y
      @z*=b.z
      return @
    else if typeof b is "number"
      @x = int(@x*b)
      @y = int(@y*b)
      @z = int(@z*b)
      return @
  #   v /= b
  div: (b) ->
    if b instanceof vec3i
      @x = @x // b.x
      @y = @y // b.y
      @z = @z // b.z
      return @
    else if typeof b is "number"
      @x = @x // b
      @y = @y // b
      @z = @z // b
      return @
vmath.vec3i = vec3i

# 4d integer vector
class vec4i
  constructor: (@x = 0, @y = 0, @z = 0, @w = 0) ->
    @x = int @x
    @y = int @y
    @z = int @z
    @w = int @w
  clone: -> new vec4i(@x,@y,@z,@w)
  # 4d integer component-wise arithmetic operators -----------
  #   -v
  opposite: -> new vec4i(-@x,-@y,-@z,-@w)
  #   v += b
  sum: (b) ->
    if b instanceof vec4i
      @x+=b.x
      @y+=b.y
      @z+=b.z
      @w+=b.w
      return @
  #   v -= b
  sub: (b) ->
    if b instanceof vec4i
      @x-=b.x
      @y-=b.y
      @z-=b.z
      @w-=b.w
      return @
  #   v *= b
  mul: (b) ->
    if b instanceof vec4i
      @x*=b.x
      @y*=b.y
      @z*=b.z
      @w*=b.w
      return @
    else if typeof b is "number"
      @x = int(@x*b)
      @y = int(@y*b)
      @z = int(@z*b)
      @w = int(@w*b)
      return @
  #   v /= b
  div: (b) ->
    if b instanceof vec4i
      @x = @x // b.x
      @y = @y // b.y
      @z = @z // b.z
      @w = @w // b.w
      return @
    else if typeof b is "number"
      @x = @x // b
      @y = @y // b
      @z = @z // b
      @w = @w // b
      return @
vmath.vec4i = vec4i

# 3d coordinate frame
class frame3f
  constructor: (@o = zero3f.clone(), @x = x3f.clone(), @y = y3f.clone(), @z = z3f.clone()) ->
    @o = @o.clone()
    @x = @x.clone()
    @y = @y.clone()
    @z = @z.clone()
  clone: -> new frame3f(@o,@x,@y,@z)
vmath.frame3f = frame3f

# 4x4 Matrix
class mat4f
  constructor: (x_x = x4f, x_y = y4f, x_z = z4f, x_w = w4f, y_x,y_y,y_z,y_w, z_x,z_y,z_z,z_w, w_x,w_y,w_z,w_w) ->
    if arguments.length is 4 or arguments.length is 0
      @x = x_x.clone()
      @y = x_y.clone()
      @z = x_z.clone()
      @w = x_w.clone()
    else if arguments.length is 16
      @x = new vec4f(x_x, x_y, x_z, x_w)
      @y = new vec4f(y_x, y_y, y_z, y_w)
      @z = new vec4f(z_x, z_y, z_z, z_w)
      @w = new vec4f(w_x, w_y, w_z, w_w)
    else alert "Error in function mat4f constructor"
  clone: -> new mat4f(@x,@y,@z,@w)
  # 4d component-wise arithmetic operators -----------
  #   -v
  opposite: -> new mat4f(-@x,-@y,-@z,-@w)
  #   v += b
  sum: (b) ->
    if b instanceof mat4f
      @x.sum(b.x)
      @y.sum(b.y)
      @z.sum(b.z)
      @w.sum(b.w)
      return @
  #   v -= b
  sub: (b) ->
    if b instanceof mat4f
      @x.sub(b.x)
      @y.sub(b.y)
      @z.sub(b.z)
      @w.sub(b.w)
      return @
  #   v *= b
  mul: (b) ->
    if b instanceof mat4f
      temp = mul(this,b)
      @x = temp.x
      @y = temp.y
      @z = temp.z
      @w = temp.w
      return @
    else if typeof b is "number"
      @x.mul(b)
      @y.mul(b)
      @z.mul(b)
      @w.mul(b)
      return @
  #   v /= b
  div: (b) ->
    if typeof b is "number"
      @x.div(b)
      @y.div(b)
      @z.div(b)
      @w.div(b)
      return @
vmath.mat4f = mat4f

# 1D Bounding Interval
class range1f
  constructor: (@min = 1,@max = -1) ->
vmath.range1f = range1f

# 3D Bounding Interval
class range3f
  constructor: (@min = one3f.clone(),@max = one3f.opposite()) ->
    @min = @min.clone()
    @max = @max.clone()
vmath.range3f = range3f

if window? then window.vmath = vmath # for the web
if module?.exports? then module.exports = vmath # for node
