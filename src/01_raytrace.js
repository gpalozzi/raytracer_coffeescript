// Generated by CoffeeScript 1.7.1
(function() {
  var exec, image, intersect, raytrace, raytrace_ray, rtrace, scene, vmath;

  rtrace = {};

  if (typeof window !== "undefined" && window !== null) {
    window.rtrace = rtrace;
  }

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = rtrace;
  }

  scene = window.scene;

  image = window.image;

  vmath = window.vmath;

  rtrace.intersection3f = (function() {
    function intersection3f(hit, ray_t, pos, norm, mat) {
      this.hit = hit != null ? hit : false;
      this.ray_t = ray_t;
      this.pos = pos;
      this.norm = norm;
      this.mat = mat;
    }

    return intersection3f;

  })();

  rtrace.ray3f_epsilon = 0.0005;

  rtrace.ray3f_rayinf = 1000000;

  rtrace.ray3f = (function() {
    function ray3f(e, d, tmin, tmax) {
      this.e = e != null ? e : vmath.zero3f.clone();
      this.d = d != null ? d : vmath.z3f.clone();
      this.tmin = tmin != null ? tmin : rtrace.ray3f_epsilon;
      this.tmax = tmax != null ? tmax : rtrace.ray3f_rayinf;
    }

    ray3f.prototype["eval"] = function(t) {
      return vmath.sum(this.e, vmath.mul(this.d, t));
    };

    return ray3f;

  })();

  rtrace.make_segment = function(a, b) {
    if (a instanceof vmath.vec3f && b instanceof vmath.vec3f) {
      return new rtrace.ray3f(a.clone(), vmath.normalize(vmath.sub(b, a)), rtrace.ray3f_epsilon, vmath.dist(a, b) - 2 * rtrace.ray3f_epsilon);
    }
  };

  rtrace.transform_ray = function(f, v) {
    if (f instanceof vmath.frame3f && v instanceof rtrace.ray3f) {
      return new rtrace.ray3f(vmath.transform_point(f, v.e), vmath.transform_vector(f, v.d), v.tmin, v.tmax);
    }
  };

  rtrace.transform_ray_inverse = function(f, v) {
    if (f instanceof vmath.frame3f && v instanceof rtrace.ray3f) {
      return new rtrace.ray3f(vmath.transform_point_inverse(f, v.e), vmath.transform_vector_inverse(f, v.d), v.tmin, v.tmax);
    }
  };

  intersect = function(s, ray) {
    var a, b, c, d, intersection, p, surface, t, tray, _i, _len, _ref;
    if (s instanceof scene.Scene && ray instanceof rtrace.ray3f) {
      intersection = new rtrace.intersection3f;
      _ref = s.surfaces;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        surface = _ref[_i];
        if (surface.isquad) {
          tray = rtrace.transform_ray_inverse(surface.frame, ray);
          if (tray.d.z === 0) {
            continue;
          }
          t = -tray.e.z / tray.d.z;
          p = tray["eval"](t);
          if (surface.radius < p.x || -surface.radius > p.x || surface.radius < p.y || -surface.radius > p.y) {
            continue;
          }
          if (t < tray.tmin || t > tray.tmax) {
            continue;
          }
          if (t > intersection.ray_t && intersection.hit) {
            continue;
          }
          intersection.hit = true;
          intersection.ray_t = t;
          intersection.pos = vmath.transform_point(surface.frame, p);
          intersection.norm = vmath.transform_normal(surface.frame, vmath.z3f);
          intersection.mat = surface.mat.clone();
        } else {
          tray = rtrace.transform_ray_inverse(surface.frame, ray);
          a = vmath.lengthSqr(tray.d);
          b = 2 * vmath.dot(tray.d, tray.e);
          c = vmath.lengthSqr(tray.e) - surface.radius * surface.radius;
          d = b * b - 4 * a * c;
          if (d < 0) {
            continue;
          }
          t = (-b - Math.sqrt(d)) / (2 * a);
          if (!(t >= tray.tmin && t <= tray.tmax)) {
            continue;
          }
          if (t > intersection.ray_t && intersection.hit) {
            continue;
          }
          intersection.hit = true;
          intersection.ray_t = t;
          intersection.pos = vmath.transform_point(surface.frame, tray["eval"](t));
          intersection.norm = vmath.transform_normal(surface.frame, vmath.normalize(tray["eval"](t)));
          intersection.mat = surface.mat.clone();
        }
      }
      return intersection;
    }
  };

  raytrace_ray = function(s, ray) {
    var c, cl, h, intersection, l, light, rr, shade, _i, _len, _ref;
    if (s instanceof scene.Scene && ray instanceof rtrace.ray3f) {
      intersection = intersect(s, ray);
      if (!intersection.hit) {
        return s.background;
      }
      c = vmath.mul(s.ambient, intersection.mat.kd);
      _ref = s.lights;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        light = _ref[_i];
        cl = vmath.div(light.intensity, vmath.lengthSqr(vmath.sub(intersection.pos, light.frame.o)));
        l = vmath.normalize(vmath.sub(light.frame.o, intersection.pos));
        h = vmath.normalize(vmath.sum(ray.d.opposite(), l));
        shade = vmath.mul(cl, vmath.max(vmath.dot(intersection.norm, l), 0));
        shade.mul(vmath.sum(intersection.mat.kd, vmath.mul(intersection.mat.ks, Math.pow(vmath.max(0, vmath.dot(intersection.norm, h)), intersection.mat.n))));
        if (vmath.equal(shade, vmath.zero3f)) {
          continue;
        }
        if (!intersect(s, rtrace.make_segment(intersection.pos, light.frame.o)).hit) {
          c.sum(shade);
        }
      }
      if (!(vmath.equal(intersection.mat.kr, vmath.zero3f))) {
        rr = new rtrace.ray3f(intersection.pos.clone(), vmath.sub(ray.d, vmath.mul(2 * vmath.dot(ray.d, intersection.norm), intersection.norm)));
        c.sum(vmath.mul(intersection.mat.kr, raytrace_ray(s, rr)));
      }
      return c;
    }
  };

  raytrace = function(s) {
    var color, i, ii, img, j, jj, p, ray, u, v, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    if (s instanceof scene.Scene) {
      img = new image.image3f(s.image_width, s.image_height);
      if (s.image_samples <= 1) {
        for (j = _i = 0, _ref = s.image_height; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
          for (i = _j = 0, _ref1 = s.image_width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            u = (i + 0.5) / s.image_width;
            v = (j + 0.5) / s.image_height;
            ray = rtrace.transform_ray(s.camera.frame, new rtrace.ray3f(vmath.zero3f.clone(), vmath.normalize(new vmath.vec3f([(u - 0.5) * s.camera.width, (v - 0.5) * s.camera.height, -1]))));
            color = raytrace_ray(s, ray);
            img.set_at(i, j, color);
          }
        }
      } else {
        for (j = _k = 0, _ref2 = s.image_height; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
          for (i = _l = 0, _ref3 = s.image_width; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
            for (jj = _m = 0, _ref4 = s.image_samples; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; jj = 0 <= _ref4 ? ++_m : --_m) {
              for (ii = _n = 0, _ref5 = s.image_samples; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; ii = 0 <= _ref5 ? ++_n : --_n) {
                u = (i + (ii + 0.5) / s.image_samples) / s.image_width;
                v = (j + (jj + 0.5) / s.image_samples) / s.image_height;
                ray = rtrace.transform_ray(s.camera.frame, new rtrace.ray3f(vmath.zero3f.clone(), vmath.normalize(new vmath.vec3f([(u - 0.5) * s.camera.width, (v - 0.5) * s.camera.height, -1]))));
                p = img.at(i, j);
                p.sum(raytrace_ray(s, ray));
                img.set_at(i, j, p);
              }
            }
            p = img.at(i, j);
            p.div(s.image_samples * s.image_samples);
          }
        }
      }
      return img;
    }
  };

  exec = function(img) {
    var canv, ctx, pixel, vec, x, y, _i, _ref, _results;
    canv = document.getElementById("display");
    canv.width = img.wwidth();
    canv.height = img.hheight();
    ctx = canv.getContext("2d");
    ctx.clearRect(0, 0, canv.width, canv.height);
    _results = [];
    for (y = _i = 0, _ref = canv.height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (x = _j = 0, _ref1 = canv.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          vec = img.at(x, canv.height - 1 - y);
          pixel = [vmath.clamp(vec.x * 255, 0, 255), vmath.clamp(vec.y * 255, 0, 255), vmath.clamp(vec.z * 255, 0, 255)];
          ctx.fillStyle = "rgb(" + (Math.floor(pixel[0])) + "," + (Math.floor(pixel[1])) + "," + (Math.floor(pixel[2])) + ")";
          _results1.push(ctx.fillRect(x, y, x + 1, y + 1));
        }
        return _results1;
      })());
    }
    return _results;
  };

  rtrace.raytrace_01 = function(scene_filename) {
    var img, s;
    s = scene.load_json_scene(scene_filename);
    img = raytrace(s);
    return exec(img);
  };

}).call(this);

//# sourceMappingURL=01_raytrace.map
